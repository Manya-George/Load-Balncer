

# Load Balancer with Consistent Hashing

This project demonstrates a containerized load balancer system that distributes asynchronous client requests evenly across multiple server containers using **consistent hashing**. The servers are lightweight Flask applications running in Docker containers, and the load balancer dynamically manages replicas, health checks, and request routing.

This guide will walk you through setting up the environment, running the system, and exploring the load balancing and scaling features.

---

## Requirements

### Host Machine:

* Ubuntu 20.04 LTS or later
* Docker Engine (20.10+)
* Docker Compose (v2.15+)
* Git
* Python 3.8+ (for running tests)

---

## Setup Instructions

### 1. Update System & Install Dependencies

Update your system and install required packages:

```bash
sudo apt update && sudo apt upgrade -y
sudo apt install -y git python3 python3-pip
````

### 2. Install Docker & Docker Compose

Follow Dockerâ€™s official instructions or run:

```bash
sudo apt install -y docker.io
sudo systemctl enable --now docker
sudo usermod -aG docker $USER
newgrp docker
```

Install Docker Compose:

```bash
sudo curl -SL https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
```

Verify:

```bash
docker --version
docker-compose --version
```

### 3. Clone the Project Repository

```bash
git clone https://github.com/Manya-George/Load-Balncer.git
cd Load-Balncer
```

---

## Build and Run the System

### 4. Build Docker Images

Build server and load balancer images using Makefile:

```bash
make build
```

### 5. Start the Load Balancer and Servers

Start the load balancer and 3 server replicas:

```bash
make start
```

### 6. Stop and Clean Up Containers

To stop and remove containers:

```bash
make stop
```

Alternatively, run everything with Docker Compose:

```bash
docker-compose up --build
```

---

## How to Use

### Check Running Servers

Get the list of active server replicas:

```bash
curl http://localhost:5000/rep
```

### Add Server Replicas

Add N new server replicas by hostname:

```bash
curl -X POST http://localhost:5000/add -H "Content-Type: application/json" \
     -d '{"n":2,"hostnames":["S4","S5"]}'
```

### Remove Server Replicas

Remove N server replicas by hostname:

```bash
curl -X DELETE http://localhost:5000/rm -H "Content-Type: application/json" \
     -d '{"n":1,"hostnames":["S4"]}'
```

### Send Requests Routed by Load Balancer

Send requests to the load balancer, which routes based on consistent hashing:

```bash
curl http://localhost:5000/home
```

The response indicates which server handled the request.

---

## Implementation Details

### Server Containers

* Each server runs a Flask app exposing endpoints:

  * `/home`: Returns a greeting with server ID.
  * `/heartbeat`: Health check endpoint returning HTTP 200.

### Load Balancer

* Maintains a configurable number of server replicas (default 3).

* Uses consistent hashing with 512 hash slots and 9 virtual servers per physical server.

* Hash functions:

  * Request hash:

    $$
    H(i) = (i + 2i^2 + 17) \mod 512
    $$

  * Virtual server hash:

    $$
    \Phi(i,j) = (i^2 + j + 2j^2 + 25) \mod 512
    $$

* Linear probing resolves collisions on the hash ring.

* Routinely performs health checks on servers via `/heartbeat`.

* Automatically respawns failed servers to maintain availability.

---

## Testing & Load Analysis

Run automated tests to simulate load and analyze request distribution:

```bash
python3 tests/test_load_balancer.py
```

The tests:

* Send 10,000 asynchronous requests routed by consistent hashing.
* Collect per-server load statistics.
* Visualize request distribution and balance.
* Simulate server scaling and failure scenarios.

Results and charts are saved under the `/tests/results/` directory.

---




